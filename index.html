<!DOCTYPE html>
<html>
<head>
    <style>
        input.valid {
            background-color: lightgreen;
        }
        input.invalid {
            background-color: lightpink;
        }
        input.optional {
            background-color: lightgray;
        }
        span.hidden {
            display: none;
        }
        span.error {
            background-color: maroon;
            color: white;
            font-size: x-large;
        }
        div.wrapper {
            display: grid;
            grid-template-columns: auto auto;
        }
        input {
            width: 10ch;
        }
        table, td {
            border: 1px solid black;
        }
        td {
            width: 1.5ch;
            height: 1.5ch;
            text-align: center;
        }
    </style>
</head>
<body>
<h1>Squad Mortar Calculator</h1>
<div id='instructions'>
    <h2>Instructions</h2>
    <details>
        <summary>
            <i>(Click to expand/collapse)</i>
        </summary>
        <br>
        Input the grid and (optional) subgrid coordinates of both the mortar<br>
        position and the target position. The subgrid part is and is subdivided<br>
        using keypad keys, and you can do as many subdivisions as you please.<br><br>
        This page will automagically compute a fire solution once all inputs<br>
        are valid. Internally, this page uses the range tables for mortars<br>
        provided in-game, lerps between the values, and warns you if the<br>
        target is out of range.
        <div class='wrapper'>
            <div id='grid-coords'>
                <h3>Valid Grid Coordinates</h3>
                <ul>
                    <li>A3</li>
                    <li>b2</li>
                    <li>F02</li>
                    <li>C1-12</li>
                    <li>b3-4882111</li>
                </ul>
            </div>
            <div id='kp-table'>
                <h3>Subgrid Division</h3>
                <table>
                    <tr>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                    </tr>
                </table>
            </div>
        </div>
    </details>
</div>
<br>
<hr>
<div class='wrapper'>
    <div id='inputs'>
        <h2>Inputs</h2>
        <form oninput='validateInputs()'>
            <b>Mortar Grid</b> (Ex: A5-232)
            <br>
            <input class='invalid' type='text' id='origin-grid' placeholder='(required)' maxlength='3'/> -
            <input class='optional' type='text' id='origin-subgrid' placeholder='(optional)'/>
            <br>
            <br>
            <b>Target Grid</b> (Ex: B11-4451)
            <br>
            <input class='invalid' type='text' id='target-grid' placeholder='(required)' maxlength='3'/> -
            <input class='optional' type='text' id='target-subgrid' placeholder='(optional)'/>
            <br>
            <br>
            <b>Major Grid Size</b> (meters)
            <br>
            <input class='valid' type='number' id='size' min='1'/>
        </form>
    </div>
    <div id='outputs'>
        <h2>Outputs</h2>
        <b>Bearing:</b> <span id='bearing'>N/A</span> 
        <br>
        <br>
        <b>Elevation:</b> <span id='elevation'>N/A</span>
        <br>
        <br>
        <span id='too-close' class='error hidden'><b>TARGET TOO CLOSE</b></span>
        <span id='too-far' class='error hidden'><b>TARGET TOO FAR</b></span>
    </div>
</div>

<script>
const sizeElm = document.getElementById('size');
const originGridElm = document.getElementById('origin-grid');
const originSubgridElm = document.getElementById('origin-subgrid');
const targetGridElm = document.getElementById('target-grid');
const targetSubgridElm = document.getElementById('target-subgrid');

const bearingElm = document.getElementById('bearing');
const elevationElm = document.getElementById('elevation');

const tooCloseElm = document.getElementById('too-close');
const tooFarElm = document.getElementById('too-far');

sizeElm.value = 300;

const rangeTable = {
    50  :  1579,
    100 :  1558,
    150 :  1538,
    200 :  1517,
    250 :  1496,
    300 :  1475,
    350 :  1453,
    400 :  1431,
    450 :  1409,
    500 :  1387,
    550 :  1364,
    600 :  1341,
    650 :  1317,
    700 :  1292,
    750 :  1267,
    800 :  1240,
    850 :  1212,
    900 :  1183,
    950 :  1152,
    1000:  1118,
    1050:  1081,
    1100:  1039,
    1150:   988,
    1200:   918,
    1250:   800,
};

const charMap = {
    'a': 1,
    'b': 2,
    'c': 3,
    'd': 4,
    'e': 5,
    'f': 6,
    'g': 7,
    'h': 8,
    'i': 9,
    'j': 10,
    'k': 11,
    'l': 12,
    'm': 13,
    'n': 14,
    'o': 15,
    'p': 16,
    'q': 17,
    'r': 18,
    's': 19,
    't': 20,
    'u': 21,
    'v': 22,
    'w': 23,
    'x': 24,
    'y': 25,
    'z': 26,
};

const keypadArr = [
    {x:  0, y:  0}, // 0
    {x: -1, y:  1}, // 1
    {x:  0, y:  1}, // 2
    {x:  1, y:  1}, // 3
    {x: -1, y:  0}, // 4
    {x:  0, y:  0}, // 5
    {x:  1, y:  0}, // 6
    {x: -1, y: -1}, // 7
    {x:  0, y: -1}, // 8
    {x:  1, y: -1}, // 9
];

function validateInputs() {
    let valid = true;
    console.log('validating...');
    valid &= validateGrid(originGridElm);
    valid &= validateGrid(targetGridElm);
    valid &= validateSubgrid(originSubgridElm);
    valid &= validateSubgrid(targetSubgridElm);

    if (valid)
    {
        calculateSoln();
    }
    else
    {
        clearOutputs();
    }
}
validateInputs();

function clearOutputs()
{
    for (let elm of [rangeElm, bearingElm, elevationElm])
    {
        elm.innerText = 'N/A';
    }

    tooCloseElm.classList.add('hidden');
    tooFarElm.classList.add('hidden');
}

function validateGrid(elm)
{
    let val = elm.value;
    if (/^[A-Za-z][0-9]+$/.test(val))
    {
        elm.classList.add('valid');
        elm.classList.remove('invalid');
        return true;
    }

    elm.classList.add('invalid');
    elm.classList.remove('valid');
    return false;
}

function validateSubgrid(elm)
{
    let val = elm.value;
    if (!val) // empty or undef
    {
        elm.classList.add('optional');
        elm.classList.remove('valid');
        elm.classList.remove('invalid');
        return true;
    }

    if (/^[1-9]+$/.test(val))
    {
        elm.classList.add('valid');
        elm.classList.remove('optional');
        elm.classList.remove('invalid');
        return true;
    }

    elm.classList.add('invalid');
    elm.classList.remove('optional');
    elm.classList.remove('valid');
    return false;
}

function isTooClose(range)
{
    let min = 100000;
    for (let val in rangeTable)
    {
        let r = parseFloat(val);
        if (r < min)
        {
            min = r;
        }
    }
    return min > range;
}

function isTooFar(range)
{
    let max = -1;
    for (let val in rangeTable)
    {
        let r = parseFloat(val);
        if (r > max)
        {
            max = r;
        }
    }
    return max < range;
}

function calculateSoln() {
    // Inputs
    let size = parseFloat(sizeElm.value);
    let originGrid  = originGridElm.value;
    let originSubgrid = originSubgridElm.value;
    let targetGrid  = targetGridElm.value;
    let targetSubgrid = targetSubgridElm.value;

    // Calc positions
    let originPos = gridToCoord(originGrid, originSubgrid, size);
    let targetPos = gridToCoord(targetGrid, targetSubgrid, size);

    // Calc to target
    let originPosNeg = multiplyVectorByScalar(originPos, -1);
    let toTarget = addVectorToVector(targetPos, originPosNeg);
    console.log(`origin pos: ${JSON.stringify(originPos)}`);
    console.log(`target pos: ${JSON.stringify(targetPos)}`);
    console.log(`to target: ${JSON.stringify(toTarget)}`);

    // Calc bearing
    let angle = Math.atan2(toTarget.x, toTarget.y) / Math.PI * 180.0;
    if (angle < 0)
    {
        angle = 360.0 + angle;
    }
    bearingElm.innerText = `${Math.round(angle)}Â°`;

    // Calc range
    let range = getVectorMagnitude(toTarget);

    // Calc mils
    if (isTooClose(range))
    {
        tooFarElm.classList.add('hidden');
        tooCloseElm.classList.remove('hidden');
        elevationElm.innerText = 'N/A';
    }
    else if (isTooFar(range))
    {
        tooCloseElm.classList.add('hidden');
        tooFarElm.classList.remove('hidden');
        elevationElm.innerText = 'N/A';
    }
    else
    {
        tooCloseElm.classList.add('hidden');
        tooFarElm.classList.add('hidden');
        let mils = lerpRangeTable(range);
        elevationElm.innerText = `${Math.round(mils)} mils (${Math.round(range)} meters)`;
    }
}

// Returns mils
function lerpRangeTable(desiredRange) {
    let min = undefined;
    let max = undefined;
    for (let key in rangeTable) 
    {
        let range = parseFloat(key);
        // Get the lower bound as close to the desired range
        if (desiredRange > range && (!min || range > min))
        {
            min = range;
        }

        // Get the upper bound as close to the desired range
        if (desiredRange < range && (!max || range < max))
        {
            max = range;
        }
    }

    if (!min || !max) // Out of bounds, would require extrapolation
    {
        return -1;
    }

    return lerp(desiredRange, min, rangeTable[min], max, rangeTable[max]);
}

function lerp(x, x1, y1, x2, y2)
{
    let m = (y2 - y1) / (x2 - x1);
    let b = y2 - m * x2;
    return m * x + b;
}

function gridToCoord(grid, subgrid, size) {
    let pos = { 
        x: size * 0.5, 
        y: size * 0.5,
    };

    let gridX = grid[0];
    let gridY = grid.substring(1);

    let initOffset = {
        x: (charMap[gridX.toLowerCase()] - 1) * size, // TODO: Check is alpha
        y: (parseInt(gridY) - 1) * size, // TODO: Check is numeric
    }

    pos = addVectorToVector(pos, initOffset);

    if (subgrid.length > 0)
    {
        curr_size = size;
        for (let c of subgrid)
        {
            // TODO: Check is numeric
            curr_size = curr_size / 3;
            let idx = parseInt(c);
            let offset = keypadArr[idx];
            offset = multiplyVectorByScalar(offset, curr_size);
            pos = addVectorToVector(pos, offset);
        }
    }

    pos.y = -pos.y; // To make +Y be positive just for my brain.
    return pos;
}

function addVectorToVector(a, b) {
    let res = { 
        x: a.x + b.x,
        y: a.y + b.y,
    }
    return res;
}

function multiplyVectorByScalar(v, scale) {
    let res = { 
        x: v.x * scale,
        y: v.y * scale,
    }
    return res;
}

function getVectorMagnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}
</script>
</body>
</html>
