<!DOCTYPE html>
<html>
<body>

<h1>Squad Mortar Calculator</h1>
<div id='inputs'>
    <h2>Inputs</h2>
    <form>
        <b>Mortar Grid</b> (Ex: A-5-232)
        <br>
        <input type='text' id='origin-x' placeholder='(required)' maxlength='1'/> -
        <input type='text' id='origin-y' placeholder='(required)' maxlength='2'/> -
        <input type='text' id='origin-k' placeholder='(optional)'/>
        <br>
        <br>
        <b>Target Grid</b> (Ex: B-11-4451)
        <br>
        <input type='text' id='target-x' placeholder='(required)' maxlength='1'/> -
        <input type='text' id='target-y' placeholder='(required)' maxlength='2'/> -
        <input type='text' id='target-k' placeholder='(optional)'/>
        <br>
        <br>
        <b>Major Grid Size</b> (meters)
        <br>
        <input type='number' id='size' min='1'/>
        <br>
        <br>
        <button type='button' onclick='calculate()'>Calculate</button>
    </form>
</div>
<hr>
<div id='outputs'>
    <h2>Outputs</h2>
    <b>Range:</b> <span id='range'>0 meters</span>
    <br>
    <br>
    <b>Bearing:</b> <span id='bearing'>0°</span> 
    <br>
    <br>
    <b>Elevation:</b> <span id='elevation'>0 mils</span>
</div>

<script>
document.getElementById('size').value = 300;

const rangeTable = {
    50  :  1579,
    100 :  1558,
    150 :  1538,
    200 :  1517,
    250 :  1496,
    300 :  1475,
    350 :  1453,
    400 :  1431,
    450 :  1409,
    500 :  1387,
    550 :  1364,
    600 :  1341,
    650 :  1317,
    700 :  1292,
    750 :  1267,
    800 :  1240,
    850 :  1212,
    900 :  1183,
    950 :  1152,
    1000:  1118,
    1050:  1081,
    1100:  1039,
    1150:   988,
    1200:   918,
    1250:   800,
};

const charMap = {
    'a': 1,
    'b': 2,
    'c': 3,
    'd': 4,
    'e': 5,
    'f': 6,
    'g': 7,
    'h': 8,
    'i': 9,
    'j': 10,
    'k': 11,
    'l': 12,
    'm': 13,
    'n': 14,
    'o': 15,
    'p': 16,
    'q': 17,
    'r': 18,
    's': 19,
    't': 20,
    'u': 21,
    'v': 22,
    'w': 23,
    'x': 24,
    'y': 25,
    'z': 26,
}

const keypadArr = [
    {x:  0, y:  0}, // 0
    {x: -1, y:  1}, // 1
    {x:  0, y:  1}, // 2
    {x:  1, y:  1}, // 3
    {x: -1, y:  0}, // 4
    {x:  0, y:  0}, // 5
    {x:  1, y:  0}, // 6
    {x: -1, y: -1}, // 7
    {x:  0, y: -1}, // 8
    {x:  1, y: -1}, // 9
]

function calculate() {
    // Inputs
    let size = parseFloat(document.getElementById('size').value);
    let originX  = document.getElementById('origin-x').value;
    let originY  = document.getElementById('origin-y').value;
    let originKp = document.getElementById('origin-k').value;
    let targetX  = document.getElementById('target-x').value;
    let targetY  = document.getElementById('target-y').value;
    let targetKp = document.getElementById('target-k').value;

    // Calc positions
    let originPos = gridToCoord(originX, originY, originKp, size);
    let targetPos = gridToCoord(targetX, targetY, targetKp, size);

    // Calc to target
    let originPosNeg = multiplyVectorByScalar(originPos, -1);
    let toTarget = addVectorToVector(targetPos, originPosNeg);
    console.log(`origin pos: ${JSON.stringify(originPos)}`);
    console.log(`target pos: ${JSON.stringify(targetPos)}`);
    console.log(`to target: ${JSON.stringify(toTarget)}`);

    // Calc bearing
    let angle = Math.atan2(toTarget.x, toTarget.y) / Math.PI * 180.0;
    if (angle < 0)
    {
        angle = 360.0 + angle;
    }

    // Calc range
    let range = getVectorMagnitude(toTarget);

    // Calc mils
    let mils = lerpRangeTable(range);

    // Outputs
    let bearingElem = document.getElementById('bearing');
    let elevationElem = document.getElementById('elevation');
    let rangeElem = document.getElementById('range');

    bearingElem.innerText = `${Math.round(angle)}°`;
    elevationElem.innerText = `${Math.round(mils)} mils`;
    rangeElem.innerText = `${Math.round(range)} meters`;
   
}

// Returns mils
function lerpRangeTable(desiredRange) {
    let min = undefined;
    let max = undefined;
    for (let key in rangeTable) 
    {
        let range = parseFloat(key);
        // Get the lower bound as close to the desired range
        if (desiredRange > range && (!min || range > min))
        {
            min = range;
        }

        // Get the upper bound as close to the desired range
        if (desiredRange < range && (!max || range < max))
        {
            max = range;
        }
    }

    if (!min || !max) // Out of bounds, would require extrapolation
    {
        return -1;
    }

    return lerp(desiredRange, min, rangeTable[min], max, rangeTable[max]);
}

function lerp(x, x1, y1, x2, y2)
{
    let m = (y2 - y1) / (x2 - x1);
    let b = y2 - m * x2;
    return m * x + b;
}

function gridToCoord(gridX, gridY, gridKp, size) {
    let pos = { 
        x: size * 0.5, 
        y: size * 0.5,
    };

    let initOffset = {
        x: (charMap[gridX.toLowerCase()] - 1) * size, // TODO: Check is alpha
        y: (parseInt(gridY) - 1) * size, // TODO: Check is numeric
    }

    pos = addVectorToVector(pos, initOffset);

    if (gridKp.length > 0)
    {
        curr_size = size;
        for (let c of gridKp)
        {
            // TODO: Check is numeric
            curr_size = curr_size / 3;
            let idx = parseInt(c);
            let offset = keypadArr[idx];
            offset = multiplyVectorByScalar(offset, curr_size);
            pos = addVectorToVector(pos, offset);
        }
    }

    pos.y = -pos.y; // To make +Y be positive just for my brain.
    return pos;
}

function addVectorToVector(a, b) {
    let res = { 
        x: a.x + b.x,
        y: a.y + b.y,
    }
    return res;
}

function multiplyVectorByScalar(v, scale) {
    let res = { 
        x: v.x * scale,
        y: v.y * scale,
    }
    return res;
}

function getVectorMagnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

</script>

</body>
</html>
